name: Submodule Sync Check

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
      - develop

permissions:
  contents: write
  pull-requests: write

jobs:
  check-submodules:
    name: Check Submodule Status
    runs-on: ubuntu-latest
    outputs:
      outdated-submodules: ${{ steps.check.outputs.outdated }}
      has-outdated: ${{ steps.check.outputs.has_outdated }}
      comment-id: ${{ steps.comment.outputs.comment-id }}

    steps:
      - name: Checkout repository with submodules
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          submodules: true
          fetch-depth: 0

      - name: Check for .gitmodules file
        id: has-submodules
        run: |
          if [ -f ".gitmodules" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ .gitmodules file found"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No .gitmodules file found - skipping submodule checks"
          fi

      - name: Parse and check all submodules
        id: check
        if: steps.has-submodules.outputs.exists == 'true'
        run: |
          # Initialize arrays
          outdated_modules=()
          all_modules=()

          # Parse .gitmodules to get all submodules
          while IFS= read -r line; do
            if [[ $line =~ ^\[submodule\ \"(.+)\"\] ]]; then
              submodule_name="${BASH_REMATCH[1]}"
            elif [[ $line =~ path\ =\ (.+) ]]; then
              submodule_path="${BASH_REMATCH[1]}"
              all_modules+=("$submodule_path")

              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo "üì¶ Checking: $submodule_name ($submodule_path)"

              # Enter submodule directory
              cd "$submodule_path" || continue

              # Get current commit
              current_commit=$(git rev-parse HEAD)
              echo "   Current commit: $current_commit"

              # Fetch latest from remote
              git fetch origin --quiet

              # Get the default branch name
              default_branch=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5)
              echo "   Default branch: $default_branch"

              # Get latest commit on default branch
              latest_commit=$(git rev-parse origin/$default_branch)
              echo "   Latest commit: $latest_commit"

              # Compare commits
              if [ "$current_commit" != "$latest_commit" ]; then
                echo "   ‚ö†Ô∏è  OUTDATED - Updates available!"

                # Get number of commits behind
                commits_behind=$(git rev-list --count HEAD..origin/$default_branch)
                echo "   üìä $commits_behind commit(s) behind"

                # Add to outdated list
                outdated_entry="${submodule_path}|${submodule_name}|${current_commit}|${latest_commit}|${commits_behind}|${default_branch}"
                outdated_modules+=("$outdated_entry")
              else
                echo "   ‚úÖ Up to date!"
              fi

              cd - > /dev/null
            fi
          done < .gitmodules

          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

          # Create outputs
          if [ ${#outdated_modules[@]} -eq 0 ]; then
            echo "has_outdated=false" >> $GITHUB_OUTPUT
            echo "outdated=" >> $GITHUB_OUTPUT
            echo "‚úÖ All ${#all_modules[@]} submodule(s) are up to date!"
          else
            echo "has_outdated=true" >> $GITHUB_OUTPUT

            # Convert to JSON properly escaped for multiline output
            outdated_json=$(printf '%s\n' "${outdated_modules[@]}" | jq -R . | jq -s -c .)

            # Use heredoc format for multiline output
            echo "outdated<<EOF" >> $GITHUB_OUTPUT
            echo "$outdated_json" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            echo "‚ö†Ô∏è  Found ${#outdated_modules[@]} outdated submodule(s)"
          fi

      - name: Create or update PR comment
        id: comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
            });

            // Find existing bot comment with unique marker
            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('<!-- submodule-sync-status -->')
            );

            const hasOutdated = '${{ steps.check.outputs.has_outdated }}' === 'true';
            const outdatedData = ${{ steps.check.outputs.outdated || '[]' }};

            // Build comment body
            let commentBody = '<!-- submodule-sync-status -->\n';
            commentBody += '## üîÑ Submodule Sync Status\n\n';

            if (!hasOutdated) {
              commentBody += '‚úÖ **All submodules are up to date!**\n\n';
              commentBody += `Checked: ${new Date().toISOString()}\n`;
            } else {
              commentBody += '‚ö†Ô∏è **Outdated Submodules Detected**\n\n';
              commentBody += `${outdatedData.length} submodule(s) need updating:\n\n`;

              commentBody += '| Submodule | Status | Behind | Actions |\n';
              commentBody += '|-----------|--------|--------|----------|\n';

              outdatedData.forEach(entry => {
                const [path, name, current, latest, behind, branch] = entry.split('|');
                const shortCurrent = current.substring(0, 7);
                const shortLatest = latest.substring(0, 7);
                commentBody += `| **${name}**<br/>\`${path}\` | \`${shortCurrent}\` ‚Üí \`${shortLatest}\` | ${behind} commits | ‚è∏Ô∏è Awaiting approval |\n`;
              });

              commentBody += '\n### üìã Next Steps\n\n';
              commentBody += '1. Go to the **Actions** tab\n';
              commentBody += '2. Find the "Submodule Sync Check" workflow\n';
              commentBody += '3. Approve each submodule update individually\n\n';
              commentBody += '> ‚ö†Ô∏è **Manual approval required** for each submodule\n';
            }

            commentBody += `\n---\n*Last updated: ${new Date().toISOString()}*`;

            let comment;
            if (botComment) {
              // Update existing comment
              comment = await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
              console.log('Updated existing comment:', botComment.id);
            } else {
              // Create new comment
              comment = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: commentBody
              });
              console.log('Created new comment:', comment.data.id);
            }

            core.setOutput('comment-id', comment.data.id);

  prepare-matrix:
    name: Prepare Update Jobs
    runs-on: ubuntu-latest
    needs: check-submodules
    if: needs.check-submodules.outputs.has-outdated == 'true'
    outputs:
      matrix: ${{ steps.create-matrix.outputs.matrix }}

    steps:
      - name: Create matrix from outdated submodules
        id: create-matrix
        run: |
          outdated='${{ needs.check-submodules.outputs.outdated-submodules }}'

          matrix=$(echo "$outdated" | jq -c 'map(split("|") | {
            path: .[0],
            name: .[1],
            current: .[2],
            latest: .[3],
            behind: .[4],
            branch: .[5]
          })')

          echo "matrix={\"include\":$matrix}" >> $GITHUB_OUTPUT

  sync-submodule:
    name: Update ${{ matrix.name }}
    runs-on: ubuntu-latest
    needs: [check-submodules, prepare-matrix]
    if: needs.check-submodules.outputs.has-outdated == 'true'
    strategy:
      matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}
      fail-fast: false

    environment:
      name: submodule-update-approval
      url: https://github.com/${{ github.repository }}/pull/${{ github.event.pull_request.number }}

    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          submodules: true
          token: ${{ secrets.ADMIN_BOT_TOKEN }}
          fetch-depth: 0

      - name: Configure Git
        run: |
          # === ADMIN BOT IDENTITY ===
          # Replace these with your admin bot account details
          # Format: "Bot Name" and "bot-username"
          git config user.name "Trvia-Admin"
          git config user.email "triva-admin@users.noreply.github.com"
          # === END ADMIN BOT IDENTITY ===

      - name: Update submodule to latest
        id: update
        run: |
          echo "üì¶ Updating: ${{ matrix.name }}"
          echo "   Path: ${{ matrix.path }}"
          echo "   From: ${{ matrix.current }}"
          echo "   To: ${{ matrix.latest }}"

          cd "${{ matrix.path }}"
          git fetch origin
          git checkout origin/${{ matrix.branch }}
          new_commit=$(git rev-parse HEAD)
          echo "new_commit=$new_commit" >> $GITHUB_OUTPUT
          cd -

          git add "${{ matrix.path }}"

          if ! git diff --cached --quiet; then
            git commit -m "chore(submodules): update ${{ matrix.name }} to latest" \
              -m "Submodule: ${{ matrix.name }}" \
              -m "Path: ${{ matrix.path }}" \
              -m "Updated: ${{ matrix.current }} ‚Üí ${new_commit}" \
              -m "Commits behind: ${{ matrix.behind }}" \
              -m "Branch: ${{ matrix.branch }}" \
              -m "" \
              -m "Co-authored-by: Trvia-Admin <triva-admin@users.noreply.github.com>"

            git push
            echo "‚úÖ Updated and pushed!"
          else
            echo "‚ÑπÔ∏è  No changes"
          fi

      - name: Update PR comment
        uses: actions/github-script@v7
        if: success()
        with:
          script: |
            const commentId = '${{ needs.check-submodules.outputs.comment-id }}';

            if (!commentId || commentId === '') {
              console.log('No comment ID found, skipping update');
              return;
            }

            try {
              const { data: comment } = await github.rest.issues.getComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId
              });

              // Replace the specific row for this submodule
              const oldRow = `| **${{ matrix.name }}**<br/>\`${{ matrix.path }}\` | \`${{ matrix.current }}\` ‚Üí \`${{ matrix.latest }}\` | ${{ matrix.behind }} commits | ‚è∏Ô∏è Awaiting approval |`;
              const newRow = `| **${{ matrix.name }}**<br/>\`${{ matrix.path }}\` | \`${{ matrix.current }}\` ‚Üí \`${{ steps.update.outputs.new_commit }}\` | ${{ matrix.behind }} commits | ‚úÖ Updated |`;

              const updatedBody = comment.body.replace(oldRow, newRow);

              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId,
                body: updatedBody
              });

              console.log('Updated comment for submodule: ${{ matrix.name }}');
            } catch (error) {
              console.log('Error updating comment:', error.message);
            }

  finalize:
    name: Finalize Status
    runs-on: ubuntu-latest
    needs: [check-submodules, sync-submodule]
    if: always() && needs.check-submodules.outputs.has-outdated == 'true' && github.event_name == 'pull_request'

    steps:
      - name: Update final comment
        uses: actions/github-script@v7
        with:
          script: |
            const commentId = '${{ needs.check-submodules.outputs.comment-id }}';
            const result = '${{ needs.sync-submodule.result }}';

            if (!commentId || commentId === '') {
              console.log('No comment ID found, skipping update');
              return;
            }

            try {
              const { data: comment } = await github.rest.issues.getComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId
              });

              // Remove any existing status section
              let bodyWithoutStatus = comment.body.replace(/\n\n---\n\n[‚úÖ‚è∏Ô∏è‚è≠Ô∏è‚ö†Ô∏è].*$/s, '');

              // Add new status
              let status = '\n\n---\n\n';
              if (result === 'success') {
                status += '‚úÖ **All submodules updated successfully!**';
              } else if (result === 'cancelled') {
                status += '‚è∏Ô∏è **Updates cancelled** - Re-run workflow to try again';
              } else if (result === 'skipped') {
                status += '‚è≠Ô∏è **Updates skipped** - Manual approval not provided';
              } else {
                status += '‚ö†Ô∏è **Some updates failed** - Check workflow logs';
              }

              status += `\n\n*Completed: ${new Date().toISOString()}*`;

              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId,
                body: bodyWithoutStatus + status
              });

              console.log('Final status updated');
            } catch (error) {
              console.log('Error updating final comment:', error.message);
            }
