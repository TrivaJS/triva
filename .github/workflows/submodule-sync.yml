name: Submodule Sync Check

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
      - develop
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  check-submodules:
    name: Check Submodule Status
    runs-on: ubuntu-latest
    outputs:
      outdated-submodules: ${{ steps.check.outputs.outdated }}
      has-outdated: ${{ steps.check.outputs.has_outdated }}
      skipped-submodules: ${{ steps.check.outputs.skipped }}
      comment-id: ${{ steps.comment.outputs.comment-id }}

    steps:
      - name: Checkout repository with submodules
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          submodules: recursive
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for .gitmodules file
        id: has-submodules
        run: |
          if [ -f ".gitmodules" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ .gitmodules file found"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No .gitmodules file found - skipping submodule checks"
          fi

      - name: Parse and check all submodules
        id: check
        if: steps.has-submodules.outputs.exists == 'true'
        run: |
          # Initialize arrays
          outdated_modules=()
          skipped_modules=()
          all_modules=()
          accessible_modules=0

          # Parse .gitmodules to get all submodules
          while IFS= read -r line; do
            if [[ $line =~ ^\[submodule\ \"(.+)\"\] ]]; then
              submodule_name="${BASH_REMATCH[1]}"
            elif [[ $line =~ path\ =\ (.+) ]]; then
              submodule_path="${BASH_REMATCH[1]}"
              all_modules+=("$submodule_path")

              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo "üì¶ Checking: $submodule_name ($submodule_path)"

              # Check if submodule directory exists
              if [ ! -d "$submodule_path" ]; then
                echo "   ‚ö†Ô∏è  Directory not found - skipping"
                skipped_modules+=("${submodule_path}|${submodule_name}|Directory not found")
                continue
              fi

              # Enter submodule directory
              if ! cd "$submodule_path" 2>/dev/null; then
                echo "   ‚ö†Ô∏è  Cannot access directory - skipping"
                skipped_modules+=("${submodule_path}|${submodule_name}|Cannot access directory")
                continue
              fi

              # Check if it's a valid git repository
              if ! git rev-parse --git-dir > /dev/null 2>&1; then
                echo "   ‚ö†Ô∏è  Not a valid git repository - skipping"
                skipped_modules+=("${submodule_path}|${submodule_name}|Not a git repository")
                cd - > /dev/null
                continue
              fi

              # Get current commit
              if ! current_commit=$(git rev-parse HEAD 2>/dev/null); then
                echo "   ‚ö†Ô∏è  Cannot determine current commit - skipping"
                skipped_modules+=("${submodule_path}|${submodule_name}|Cannot determine commit")
                cd - > /dev/null
                continue
              fi
              echo "   Current commit: $current_commit"

              # Try to fetch latest from remote
              echo "   Fetching from remote..."
              if ! git fetch origin --quiet 2>/dev/null; then
                echo "   ‚ö†Ô∏è  Cannot fetch from remote (possibly private or not accessible) - skipping"
                skipped_modules+=("${submodule_path}|${submodule_name}|Cannot fetch (private/inaccessible)")
                cd - > /dev/null
                continue
              fi

              # Get the default branch name
              if ! default_branch=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d' ' -f5); then
                echo "   ‚ö†Ô∏è  Cannot determine default branch - trying 'main' and 'master'"
                
                # Try common branch names
                if git rev-parse origin/main >/dev/null 2>&1; then
                  default_branch="main"
                elif git rev-parse origin/master >/dev/null 2>&1; then
                  default_branch="master"
                else
                  echo "   ‚ö†Ô∏è  Cannot find default branch - skipping"
                  skipped_modules+=("${submodule_path}|${submodule_name}|Cannot determine default branch")
                  cd - > /dev/null
                  continue
                fi
              fi
              echo "   Default branch: $default_branch"

              # Get latest commit on default branch
              if ! latest_commit=$(git rev-parse origin/$default_branch 2>/dev/null); then
                echo "   ‚ö†Ô∏è  Cannot determine latest commit - skipping"
                skipped_modules+=("${submodule_path}|${submodule_name}|Cannot determine latest commit")
                cd - > /dev/null
                continue
              fi
              echo "   Latest commit: $latest_commit"

              # Successfully accessed - increment counter
              ((accessible_modules++))

              # Compare commits
              if [ "$current_commit" != "$latest_commit" ]; then
                echo "   ‚ö†Ô∏è  OUTDATED - Updates available!"

                # Get number of commits behind
                if commits_behind=$(git rev-list --count HEAD..origin/$default_branch 2>/dev/null); then
                  echo "   üìä $commits_behind commit(s) behind"
                else
                  commits_behind="unknown"
                  echo "   üìä Commit count unknown"
                fi

                # Add to outdated list
                outdated_entry="${submodule_path}|${submodule_name}|${current_commit}|${latest_commit}|${commits_behind}|${default_branch}"
                outdated_modules+=("$outdated_entry")
              else
                echo "   ‚úÖ Up to date!"
              fi

              cd - > /dev/null
            fi
          done < .gitmodules

          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          echo "üìä Summary:"
          echo "   Total submodules: ${#all_modules[@]}"
          echo "   Accessible: $accessible_modules"
          echo "   Skipped: ${#skipped_modules[@]}"
          echo "   Outdated: ${#outdated_modules[@]}"

          # Create outputs for outdated submodules
          if [ ${#outdated_modules[@]} -eq 0 ]; then
            echo "has_outdated=false" >> $GITHUB_OUTPUT
            echo "outdated=" >> $GITHUB_OUTPUT
            
            if [ $accessible_modules -gt 0 ]; then
              echo "‚úÖ All $accessible_modules accessible submodule(s) are up to date!"
            fi
          else
            echo "has_outdated=true" >> $GITHUB_OUTPUT

            # Convert to JSON properly escaped for multiline output
            outdated_json=$(printf '%s\n' "${outdated_modules[@]}" | jq -R . | jq -s -c .)

            # Use heredoc format for multiline output
            echo "outdated<<EOF" >> $GITHUB_OUTPUT
            echo "$outdated_json" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            echo "‚ö†Ô∏è  Found ${#outdated_modules[@]} outdated submodule(s)"
          fi

          # Create outputs for skipped submodules
          if [ ${#skipped_modules[@]} -gt 0 ]; then
            skipped_json=$(printf '%s\n' "${skipped_modules[@]}" | jq -R . | jq -s -c .)
            
            echo "skipped<<EOF" >> $GITHUB_OUTPUT
            echo "$skipped_json" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            echo "‚ÑπÔ∏è  Skipped ${#skipped_modules[@]} submodule(s) (private/inaccessible)"
          else
            echo "skipped=" >> $GITHUB_OUTPUT
          fi

      - name: Create or update PR comment
        id: comment
        if: |
          github.event_name == 'pull_request' &&
          steps.has-submodules.outputs.exists == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const outdated = JSON.parse('${{ steps.check.outputs.outdated }}' || '[]');
            const skipped = JSON.parse('${{ steps.check.outputs.skipped }}' || '[]');
            const hasOutdated = '${{ steps.check.outputs.has_outdated }}' === 'true';
            
            let body = '## üîÑ Submodule Sync Check\n\n';
            
            if (!hasOutdated && skipped.length === 0) {
              body += '‚úÖ **All submodules are up to date!**\n\n';
              body += '---\n';
              body += '*This check runs automatically on PR updates.*';
            } else {
              if (hasOutdated) {
                body += '‚ö†Ô∏è **Outdated Submodules Detected**\n\n';
                body += 'The following submodules are behind their remote repositories:\n\n';
                body += '| Submodule | Current | Latest | Commits Behind | Branch |\n';
                body += '|-----------|---------|--------|----------------|--------|\n';
                
                outdated.forEach(entry => {
                  const [path, name, current, latest, behind, branch] = entry.split('|');
                  const currentShort = current.substring(0, 7);
                  const latestShort = latest.substring(0, 7);
                  body += `| \`${path}\` | \`${currentShort}\` | \`${latestShort}\` | ${behind} | ${branch} |\n`;
                });
                
                body += '\n### üîß How to Update\n\n';
                body += '```bash\n';
                body += 'git submodule update --remote\n';
                body += 'git add .\n';
                body += 'git commit -m "chore: update submodules"\n';
                body += '```\n\n';
              }
              
              if (skipped.length > 0) {
                body += '### ‚ÑπÔ∏è Skipped Submodules\n\n';
                body += 'The following submodules were skipped (likely private or inaccessible):\n\n';
                body += '| Submodule | Reason |\n';
                body += '|-----------|--------|\n';
                
                skipped.forEach(entry => {
                  const [path, name, reason] = entry.split('|');
                  body += `| \`${path}\` | ${reason} |\n`;
                });
                
                body += '\n*Private submodules are automatically skipped and do not affect the workflow.*\n\n';
              }
              
              body += '---\n';
              body += '*This check runs automatically on PR updates.*';
            }
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('üîÑ Submodule Sync Check')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
              core.setOutput('comment-id', botComment.id);
            } else {
              // Create new comment
              const { data: comment } = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
              core.setOutput('comment-id', comment.id);
            }

      - name: Summary
        if: always()
        run: |
          echo "# Submodule Sync Check Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check.outputs.has_outdated }}" == "true" ]; then
            echo "‚ö†Ô∏è **Status:** Outdated submodules found" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚úÖ **Status:** All accessible submodules up to date" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ -n "${{ steps.check.outputs.skipped }}" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ÑπÔ∏è Some submodules were skipped (private/inaccessible)" >> $GITHUB_STEP_SUMMARY
          fi

      # Optional: Fail the workflow if outdated submodules are found
      # Uncomment the following step if you want the workflow to fail
      # - name: Fail if outdated
      #   if: steps.check.outputs.has_outdated == 'true'
      #   run: |
      #     echo "::error::Outdated submodules detected"
      #     exit 1
