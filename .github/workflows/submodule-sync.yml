name: Submodule Sync Check

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
      - develop
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  check-submodules:
    name: Check Submodule Status
    runs-on: ubuntu-latest
    outputs:
      outdated-submodules: ${{ steps.check.outputs.outdated }}
      has-outdated: ${{ steps.check.outputs.has_outdated }}
      skipped-submodules: ${{ steps.check.outputs.skipped }}
      comment-id: ${{ steps.comment.outputs.comment-id }}

    steps:
      # CRITICAL FIX: Temporarily rename .gitmodules to prevent auto-clone
      - name: Checkout repository (without submodules)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 0

      - name: Temporarily disable submodules
        id: disable-submodules
        run: |
          # Rename .gitmodules to prevent any auto-clone attempts
          if [ -f ".gitmodules" ]; then
            mv .gitmodules .gitmodules.tmp
            echo "disabled=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Temporarily disabled submodule auto-clone"
          else
            echo "disabled=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No .gitmodules file found"
          fi

      - name: Re-enable submodules
        id: has-submodules
        run: |
          # Restore .gitmodules
          if [ -f ".gitmodules.tmp" ]; then
            mv .gitmodules.tmp .gitmodules
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ .gitmodules restored"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No submodules to check"
          fi

      - name: Initialize accessible submodules
        id: init-submodules
        if: steps.has-submodules.outputs.exists == 'true'
        run: |
          echo "Attempting to initialize submodules..."

          # Parse .gitmodules and try each submodule individually
          while IFS= read -r line; do
            if [[ $line =~ ^\[submodule\ \"(.+)\"\] ]]; then
              submodule_name="${BASH_REMATCH[1]}"
            elif [[ $line =~ path\ =\ (.+) ]]; then
              submodule_path="$line"
              submodule_path="${submodule_path#*= }"  # Remove "path = " prefix
              submodule_path=$(echo "$submodule_path" | xargs)  # Trim whitespace

              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo "Attempting: $submodule_name ($submodule_path)"

              # Try to initialize and update this specific submodule
              if git submodule init "$submodule_path" 2>/dev/null && \
                 git submodule update --init "$submodule_path" 2>/dev/null; then
                echo "‚úÖ Successfully initialized $submodule_path"
              else
                echo "‚ö†Ô∏è  Skipped $submodule_path (not accessible)"
              fi
            fi
          done < .gitmodules

          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ Submodule initialization complete"

      - name: Parse and check all submodules
        id: check
        if: steps.has-submodules.outputs.exists == 'true'
        run: |
          # Initialize arrays
          outdated_modules=()
          skipped_modules=()
          all_modules=()
          accessible_modules=0

          # Parse .gitmodules to get all submodules
          while IFS= read -r line; do
            if [[ $line =~ ^\[submodule\ \"(.+)\"\] ]]; then
              submodule_name="${BASH_REMATCH[1]}"
            elif [[ $line =~ path\ =\ (.+) ]]; then
              submodule_path="$line"
              submodule_path="${submodule_path#*= }"
              submodule_path=$(echo "$submodule_path" | xargs)
              all_modules+=("$submodule_path")

              echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
              echo "üì¶ Checking: $submodule_name ($submodule_path)"

              # Check if submodule directory exists
              if [ ! -d "$submodule_path" ]; then
                echo "   ‚ö†Ô∏è  Not accessible (private or missing repository)"
                skipped_modules+=("${submodule_path}|${submodule_name}|Repository not accessible")
                continue
              fi

              # Check if it's a git repository
              if [ ! -d "$submodule_path/.git" ] && [ ! -f "$submodule_path/.git" ]; then
                echo "   ‚ö†Ô∏è  Not initialized"
                skipped_modules+=("${submodule_path}|${submodule_name}|Not initialized")
                continue
              fi

              # Enter submodule directory
              cd "$submodule_path" || {
                echo "   ‚ö†Ô∏è  Cannot access directory"
                skipped_modules+=("${submodule_path}|${submodule_name}|Cannot access")
                continue
              }

              # Verify it's a valid git repo
              if ! git rev-parse --git-dir > /dev/null 2>&1; then
                echo "   ‚ö†Ô∏è  Invalid git repository"
                skipped_modules+=("${submodule_path}|${submodule_name}|Invalid repository")
                cd - > /dev/null || true
                continue
              fi

              # Get current commit
              current_commit=$(git rev-parse HEAD 2>/dev/null) || {
                echo "   ‚ö†Ô∏è  Cannot determine current commit"
                skipped_modules+=("${submodule_path}|${submodule_name}|Cannot read commit")
                cd - > /dev/null || true
                continue
              }
              echo "   Current: $current_commit"

              # Try to fetch from remote
              if ! git fetch origin --quiet 2>/dev/null; then
                echo "   ‚ö†Ô∏è  Cannot fetch from remote (private or inaccessible)"
                skipped_modules+=("${submodule_path}|${submodule_name}|Cannot fetch from remote")
                cd - > /dev/null || true
                continue
              fi

              # Determine default branch
              default_branch=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d' ' -f5) || {
                # Try common branch names
                if git rev-parse origin/main >/dev/null 2>&1; then
                  default_branch="main"
                elif git rev-parse origin/master >/dev/null 2>&1; then
                  default_branch="master"
                else
                  echo "   ‚ö†Ô∏è  Cannot determine default branch"
                  skipped_modules+=("${submodule_path}|${submodule_name}|Unknown branch")
                  cd - > /dev/null || true
                  continue
                fi
              }
              echo "   Branch: $default_branch"

              # Get latest commit
              latest_commit=$(git rev-parse origin/$default_branch 2>/dev/null) || {
                echo "   ‚ö†Ô∏è  Cannot determine latest commit"
                skipped_modules+=("${submodule_path}|${submodule_name}|Cannot read latest")
                cd - > /dev/null || true
                continue
              }
              echo "   Latest: $latest_commit"

              # Successfully accessed
              ((accessible_modules++))

              # Compare commits
              if [ "$current_commit" != "$latest_commit" ]; then
                echo "   ‚ö†Ô∏è  OUTDATED"

                commits_behind=$(git rev-list --count HEAD..origin/$default_branch 2>/dev/null || echo "unknown")
                echo "   Behind by: $commits_behind commits"

                outdated_entry="${submodule_path}|${submodule_name}|${current_commit}|${latest_commit}|${commits_behind}|${default_branch}"
                outdated_modules+=("$outdated_entry")
              else
                echo "   ‚úÖ Up to date"
              fi

              cd - > /dev/null || true
            fi
          done < .gitmodules

          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          echo "üìä Summary:"
          echo "   Total: ${#all_modules[@]}"
          echo "   Accessible: $accessible_modules"
          echo "   Skipped: ${#skipped_modules[@]}"
          echo "   Outdated: ${#outdated_modules[@]}"

          # Output outdated modules
          if [ ${#outdated_modules[@]} -eq 0 ]; then
            echo "has_outdated=false" >> $GITHUB_OUTPUT
            echo "outdated=" >> $GITHUB_OUTPUT
            if [ $accessible_modules -gt 0 ]; then
              echo "‚úÖ All $accessible_modules accessible submodules are up to date"
            fi
          else
            echo "has_outdated=true" >> $GITHUB_OUTPUT
            outdated_json=$(printf '%s\n' "${outdated_modules[@]}" | jq -R . | jq -s -c .)
            echo "outdated<<EOF" >> $GITHUB_OUTPUT
            echo "$outdated_json" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Found ${#outdated_modules[@]} outdated submodule(s)"
          fi

          # Output skipped modules
          if [ ${#skipped_modules[@]} -gt 0 ]; then
            skipped_json=$(printf '%s\n' "${skipped_modules[@]}" | jq -R . | jq -s -c .)
            echo "skipped<<EOF" >> $GITHUB_OUTPUT
            echo "$skipped_json" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  Skipped ${#skipped_modules[@]} submodule(s)"
          else
            echo "skipped=" >> $GITHUB_OUTPUT
          fi

          # Explicitly exit 0 to ensure success
          exit 0

      - name: Create or update PR comment
        id: comment
        if: github.event_name == 'pull_request' && steps.has-submodules.outputs.exists == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const outdated = JSON.parse('${{ steps.check.outputs.outdated }}' || '[]');
            const skipped = JSON.parse('${{ steps.check.outputs.skipped }}' || '[]');
            const hasOutdated = '${{ steps.check.outputs.has_outdated }}' === 'true';

            let body = '## üîÑ Submodule Sync Check\n\n';

            if (!hasOutdated && skipped.length === 0) {
              body += '‚úÖ **All submodules are up to date!**\n\n';
            } else {
              if (hasOutdated) {
                body += '‚ö†Ô∏è **Outdated Submodules Detected**\n\n';
                body += '| Submodule | Current | Latest | Behind | Branch |\n';
                body += '|-----------|---------|--------|--------|--------|\n';
                outdated.forEach(entry => {
                  const [path, name, current, latest, behind, branch] = entry.split('|');
                  body += `| \`${path}\` | \`${current.substring(0, 7)}\` | \`${latest.substring(0, 7)}\` | ${behind} | ${branch} |\n`;
                });
                body += '\n**Update command:**\n```bash\ngit submodule update --remote\n```\n\n';
              }

              if (skipped.length > 0) {
                body += '### ‚ÑπÔ∏è Skipped Submodules (Private/Inaccessible)\n\n';
                body += '| Submodule | Reason |\n|-----------|--------|\n';
                skipped.forEach(entry => {
                  const [path, name, reason] = entry.split('|');
                  body += `| \`${path}\` | ${reason} |\n`;
                });
                body += '\n*Private submodules are automatically skipped.*\n\n';
              }
            }

            body += '---\n*Automated check ¬∑ Runs on PR updates*';

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('üîÑ Submodule Sync Check')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }

      - name: Summary
        if: always()
        run: |
          echo "# Submodule Sync Check" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.check.outputs.has_outdated }}" == "true" ]; then
            echo "‚ö†Ô∏è Outdated submodules found" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚úÖ All accessible submodules up to date" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -n "${{ steps.check.outputs.skipped }}" ]; then
            echo "‚ÑπÔ∏è Some submodules skipped (private/inaccessible)" >> $GITHUB_STEP_SUMMARY
          fi

          # Ensure we always exit 0
          exit 0
